#!/usr/bin/env python3

from datetime import datetime, time, timezone, timedelta, date
from pathlib import Path
import shutil
import calendar
import os.path
import argparse
import sys
import httplib2.error

from google.auth.transport.requests import Request
from google.oauth2.credentials import Credentials
from google_auth_oauthlib.flow import InstalledAppFlow
from googleapiclient.discovery import build
from googleapiclient.errors import HttpError

# If modifying these scopes, delete the file token.json.
SCOPES = ["https://www.googleapis.com/auth/calendar.readonly"]


def get_duration_seconds(event) -> float:
    """Returns a gcal event duration in seconds"""
    
    # We avoid processing all-day events (no 'start' and 'end' attributes)
    if 'dateTime' not in event['start'] or 'dateTime' not in event['end']:
        return 0

    # Parse the ISO 8601 timestamps into datetime objects
    start_time = datetime.fromisoformat(event['start']['dateTime'])
    end_time = datetime.fromisoformat(event['end']['dateTime'])

    # The difference is a timedelta object
    duration = end_time - start_time

    total_seconds = duration.total_seconds()
    return total_seconds
    
    
def get_formatted_duration(total_seconds: float):
    """Returns a formatted string specifying an event duration in hours and minutes"""
    
    hours = int(total_seconds // 3600)
    minutes = int((total_seconds % 3600) // 60)

    # Apply the specific formatting rules
    if hours > 0 and minutes > 0:
        return f"{hours} hours and {minutes} min"
    elif hours > 0:
        return f"{hours} hours"
    elif minutes > 0:
        return f"{minutes} min"
    else:
        return "0 min" # For events with no duration


def get_date_min_max(date_start: date, date_end: date):
    """Returns a tuple of strings (from Date) representing end and start of an event formatted for GCal API"""
    time_min = datetime.combine(date_start, time.min, tzinfo=timezone.utc).isoformat()
    time_max = datetime.combine(date_end, time.max, tzinfo=timezone.utc).isoformat()
    return time_min, time_max


def get_today_utc():
    """" Returns today 'datetime' object"""
    return datetime.now(timezone.utc).date()


def create_parser():
    """ Create a parser """
    parser = argparse.ArgumentParser(description="Calculate total time spent in Google Calendar events.")
    parser_exclusive = parser.add_mutually_exclusive_group()
    
    parser_exclusive.add_argument("-d", "--day", action="store_true", help="Get current day events duration")
    parser_exclusive.add_argument("-w", "--week", action="store_true", help="Get current week events duration")
    parser_exclusive.add_argument("-m", "--month", action="store_true", help="Get current month events duration")
    parser_exclusive.add_argument("-y", "--year", action="store_true", help="Get current year events duration")
    parser_exclusive.add_argument("--start", type=str, help="Start date for custom timespan (--start='<YYYY-MM-DD>')")
    
    parser.add_argument("--end", type=str, help="End date for custom timespan (--end='<YYYY-MM-DD>')")
    
    parser.add_argument("--get-ids", nargs='?', const=1, help="Get the gcal IDs associated to your calendars")
    parser.add_argument("--id", type=str, help="Select calendar by calendar ID (--id='<ID>')")
    
    return parser.parse_args()


# TODO: Auth directly without credentials.json
def get_google_credentials():
    """
    Returns a Credentials object for Google Account authentication.\n
    Creates a '.config/timealloc' directory in the user home if not existent
    """
    
    creds = None
    home_dir = Path.home()
    config_dir = home_dir / ".config/timealloc"
    token_path = config_dir / "token.json"
    credentials_path = config_dir / "credentials.json"
        
    config_dir.mkdir(parents=True, exist_ok=True)
    
    if not credentials_path.exists():
        source_credentials_path = Path("credentials.json")
        
        # Check if credentials.json exists in the current directory
        if source_credentials_path.exists():
            print(f"Found '{source_credentials_path}' in the current directory.")
            config_dir.mkdir(parents=True, exist_ok=True)
            shutil.copy(source_credentials_path, credentials_path)
            print(f"Successfully copied credentials to '{credentials_path}'")
        else:
            return "'credentials.json' file not found in the current directory"
        
    # The file token.json stores the user's access and refresh tokens, and is
    # created automatically when the authorization flow completes for the first
    # time.
    if os.path.exists(token_path):
        creds = Credentials.from_authorized_user_file(token_path, SCOPES)
        
    # If there are no (valid) credentials available, let the user log in.
    if not creds or not creds.valid:
        if creds and creds.expired and creds.refresh_token:
            creds.refresh(Request())
        else:
            flow = InstalledAppFlow.from_client_secrets_file(
                credentials_path, SCOPES
            )
            creds = flow.run_local_server(port=0)
        # Save the credentials for the next run
        with open(token_path, "w") as token:
            token.write(creds.to_json())
    return creds


def build_google_service(creds):
    """Return a service object to manate auth and calendars"""
    return build("calendar", "v3", credentials=creds)

    
def get_calendars_list(service):
    """Return a list of all the calendars in the service"""
    calendars_result = service.calendarList().list().execute()
    calendars = calendars_result.get("items", [])
    return calendars


def print_calendars_id(calendars):
    """"Print the id associated with the calendars"""
    max_len = max(len(cal['summary']) for cal in calendars)
    col_width = max_len + 4

    for cal in calendars:
        print(f"{cal['summary']:<{col_width}}{cal['id']}")
    

def get_calendar_id(calendars):
    """Select and return a calendar ID interactively"""
    calendars_id_map = {}
    print("CALENDARS:")
    for i, cal in enumerate(calendars, 1):
        calendars_id_map[i] = cal["id"]
        print(f"{i}. {cal['summary']}")
    print("")
    
    try:
        calendar_selector = int(input("Select a calendar: "))
        if calendar_selector not in calendars_id_map:
            print("Invalid calendar selection")
            return
        else:
            calendar_id = calendars_id_map[calendar_selector]
            return calendar_id
    except ValueError:
        print("Please enter a valid number")
        return


def get_events(service, calendar_id, time_min, time_max):
    """"Returns all the events of selected calendar and timespan"""
    events_result = (
        service.events()
        .list(
            calendarId=calendar_id,
            timeMin=time_min,
            timeMax=time_max,
            singleEvents=True,
            orderBy="startTime",
        )
        .execute()
    )
    return events_result.get("items", [])


def print_total_duration(events):
    """Print the formatted sum of the duration of all events. All-day events are ignored"""
    total_seconds = 0.0
    for event in events:
        total_seconds = total_seconds + get_duration_seconds(event)
    print(f"---\nTOTAL EVENTS DURATION:\n{get_formatted_duration(total_seconds)}")


def main():
    args = create_parser()
    creds = get_google_credentials()
        
    try:
        service = build_google_service(creds)
        calendars = get_calendars_list(service)
        
        # Print ids and exit
        if args.get_ids:
            print_calendars_id(calendars)
            return
        
        # If no arguments, use interactive menu
        timespan_selector = -1
        if not args.day and not args.week and not args.month and not args.year and not args.start and not args.end:
            print("TIMESPANS\n1. Current day\n2. Current week\n3. Current month\n4. Current year\n5. Custom\n")
            timespan_selector = int(input("Select a timespan: "))
        
        today = get_today_utc()
        date_start, date_end = None, None
        # TODO: --end can't be a date before --start
        if args.start and not args.end or args.end and not args.start:
            print("Please specify both --start and --end flags.")
            return
        if args.day or timespan_selector == 1:
            date_start, date_end = today, today
        elif args.week or timespan_selector == 2:
            date_start = today - timedelta(days=today.weekday())
            date_end = date_start + timedelta(days=6)
        elif args.month or timespan_selector == 3:
            date_start = today.replace(day=1)
            _, date_end_num = calendar.monthrange(today.year, today.month)
            date_end = today.replace(day=date_end_num)
        elif args.year or timespan_selector == 4:
            date_start = date(today.year, 1, 1)
            date_end = date(today.year, 12, 31)
        elif (args.start and args.end) or timespan_selector == 5:
            if args.start and args.end:
                date_start = datetime.strptime(args.start, '%Y-%m-%d').date()
                date_end = datetime.strptime(args.end, '%Y-%m-%d').date()
            else:
                date_start = datetime.strptime(input("Enter first day (YYYY-MM-DD): "), '%Y-%m-%d').date()
                date_end = datetime.strptime(input("Enter last day (YYYY-MM-DD): "), '%Y-%m-%d').date()
        
        if date_start != None and date_end != None:
            time_min, time_max = get_date_min_max(date_start, date_end)
        else:
            print("No timespan specified. Please use a flag like --day, --week, or --start/--end.")
            return
        
        if args.id:
            calendar_id = args.id
        else:
            calendar_id = get_calendar_id(calendars)
        
        if not time_min or not time_max:
            return
        
        events = get_events(service, calendar_id, time_min, time_max)

        if not events:
            print("No events found.")
            return
        
        print_total_duration(events)

        return 0
    
    except HttpError as error:
        if error.resp.status == 404:
            print("Calendar not found")
        elif error.resp.status == 401:
            print("Authentication failed. Please delete token.json and re-authenticate")
        else:
            print(f"An error has occurred: {error}")
    
        return 1

    except httplib2.error.ServerNotFoundError as error:
        print(f"An error has occurred: {error}")
        
    except ValueError as error:
        print(f"Please enter a correct date with the following format: 'YYYY-MM-DD'.")


if __name__ == "__main__":
    code = main()
    sys.exit(code)
